{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Summary","text":"<p>The Bus Message Library is mainly a serialization library of bus messages.  Optionally, it also includes basic inter-process communication libraries  for shared memory and TCP/IP communications. The main purpose is to isolate the bus driver software from the rest of the application as the driver software normally is dependent on operating system and manufacturer.</p>"},{"location":"#serialization-of-bus-messages","title":"Serialization of Bus Messages","text":"<p>The library supports the following buses:</p> <ul> <li>CAN including CAN-FD.</li> <li>LIN.</li> <li>FlexRay.</li> <li>MOST.</li> <li>Ethernet (ETH).</li> </ul>"},{"location":"#communication-interfaces","title":"Communication Interfaces","text":"<p>The library supports the following communication interfaces:</p> <ul> <li>Shared Memory Broker. Single shared memory message bus.</li> <li>Shared Memory Server. Tx/Rx shared memory message bus.</li> <li>Shared Memory Client. Tx/Rx shared memory message client.</li> <li>TCP/IP Message Broker. Single shared memory with a TCP/IP server.</li> <li>TCP/IP Message Client. Client for TCP/IP servers and brokers.</li> <li>TCP/IP Message Server. Tx/Rx message TCP/IP client.</li> </ul> <p>A broker is used by applications that have one or more publishers and  one or more subscribers, typical in logger applications.  A server is used in applications where bidirectional traffic is needed, typical when running against bus drivers.</p>"},{"location":"#applications","title":"Applications","text":"<p>A number of applications use this library.  Some of them are hosted inside this repository or have their own repository. The following applications are based upon this library:</p> <ul> <li>Bus to MQTT. Subscribe to bus messages, parse the message to engineering values and forward to an MQTT broker.</li> <li>Bus to MDF. Subscribe to bus messages and log them onto an MDF file.</li> <li>Bus to Listen. Subscribe to bus messages and display the messages on a Listen Window.</li> <li>Bus Daemon. Simple executable that starts various communication interfaces.</li> <li>Bus Simulator. Simple GUI application that generates bus messages from an MDF file.</li> </ul>"},{"location":"license/","title":"The MIT License (MIT)","text":"<p>Copyright \u00a9 <code>2025</code> <code>Ingemar Hedvall</code></p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"interface/broker_and_server/","title":"Brokers and Servers","text":"<p>The library implements basic communication interfaces using shared memory or TCP/IP communication. There are two basic application types, broker or server applications.</p>"},{"location":"interface/broker_and_server/#brokers","title":"Brokers","text":"<p>A broker application implements a single internal bus with one or more publishers  and one or more subscribers.  All subscribers receive all the published messages. Brokers implement the internal bus with shared memory. Broker applications are typically used for logger applications.</p>"},{"location":"interface/broker_and_server/#servers","title":"Servers","text":"<p>A server application implements two internal buses, one TX and one RX bus. In this context, there is one server and one client.  The server can handle multiple clients, but this may cause some issues. Server applications are typically used when connecting to physical drivers.</p>"},{"location":"interface/broker_and_server/#publisher-and-subscriber-queues","title":"Publisher and Subscriber Queues","text":"<p>Each broker/server can create publishers and subscribers. Publisher sends messages while subscribers receive messages. Both publishers and subscribers implement a temporary in-memory FIFO queue.</p> <p>Publishers are created by calling the CreatePublisher() function. Similar are the subscribers created by calling the CreateSubscriber() function. Remember to call the Start() function.</p> <pre><code>// The publisher is a smart pointer (shared_ptr)\nauto publisher = broker-&gt;CreatePublisher();\npublisher-&gt;Start(); \n</code></pre>"},{"location":"interface/shared_memory_broker/","title":"Shared Memory Broker","text":"<p>The shared memory broker object is used by both publishers and subscribers application. One application shall be responsible for creating the shared memory.  This application shall call the Start() function while the other applications shouldn't  call the Start() function.</p> <pre><code>#include &lt;bus/interface/businterfacefactory.h&gt;\n// The broker is a smart pointer (unique_ptr)\nauto broker = BusInterfaceFactory::CreateBroker(\n    BrokerType::SharedMemoryBrokerType);\nbroker-&gt;Name(\"BusMemory\"); // Share memory name\nbroker-&gt;Start();    \n</code></pre>"},{"location":"interface/shared_memory_client/","title":"Shared Memory Client","text":"<p>The Shared Memory Client connects to a shared memory created by a Shared Memory Server. A Shared Memory Server has two shared memory queues, one TX-queue and one RX-queue.</p> <pre><code>#include &lt;bus/interface/businterfacefactory.h&gt;\n// The broker is a smart pointer (unique_ptr)\nauto client = BusInterfaceFactory::CreateBroker(\n    BrokerType::SharedMemoryClientType);\nclient-&gt;Name(\"BusTxRxMemory\"); // Share memory name\nclient-&gt;Start();    \n</code></pre>"},{"location":"interface/shared_memory_server/","title":"Shared Memory Server","text":"<p>A Shared Memory Server has two shared memory queues, one TX-queue and one RX-queue. A broker has only one common queue.  The server should work together with a Shared Memory Client. Although it's possible to use more than one client in an application, doing so may cause application problems. A typical application is bidirectional communication with a physical driver. This application shall call the Start() function </p> <pre><code>#include &lt;bus/interface/businterfacefactory.h&gt;\n// The broker is a smart pointer (unique_ptr)\nauto server = BusInterfaceFactory::CreateBroker(\n    BrokerType::SharedMemoryServerType);\nserver-&gt;Name(\"BusTxRxMemory\"); // Share memory name\nserver-&gt;Start();    \n</code></pre>"},{"location":"interface/tcp_broker/","title":"TCP/IP Broker","text":"<p>A TCP/IP Broker is a combination of a Shared Memory Broker and a TCP/IP Server. The broker implements a shared memory broker and connects a TCP/IP server to that memory. This enables remote connections to the bus. Use a TCP/IP Client to connect to the server.</p> <pre><code>#include &lt;bus/interface/businterfacefactory.h&gt;\n// The broker is a smart pointer (unique_ptr)\nauto broker = BusInterfaceFactory::CreateBroker(\n    BrokerType::TcpBrokerType);\nbroker-&gt;Name(\"BusMemory\"); // Share memory name\nbroker-&gt;Address(\"0.0.0.0\");\nbroker-&gt;Port(42611);\nbroker-&gt;Start();    \n</code></pre>"},{"location":"interface/tcp_client/","title":"TCP/IP Client","text":"<p>Implement a simple TCP/IP client that connects to a TCP/IP broker or a TCP/IP server.</p> <p>A typical application is bidirectional communication with a physical driver. This application shall call the Start() function.</p> <pre><code>#include &lt;bus/interface/businterfacefactory.h&gt;\n// The broker is a smart pointer (unique_ptr)\nauto client = BusInterfaceFactory::CreateBroker(\n    BrokerType::TcpClientType);\nclient-&gt;Name(\"TcpClient\"); // Name for internal use only\nclient-&gt;Address(\"127.0.0.1\");\nclient-&gt;Port(42612);\nclient-&gt;Start();    \n</code></pre>"},{"location":"interface/tcp_server/","title":"TCP/IP Server","text":"<p>Implement a TCP/IP server with no shared memory bus.  It operates against one or more TCP/IP clients.  A typical application is bidirectional communication with a physical driver. This application shall call the Start() function.</p> <pre><code>#include &lt;bus/interface/businterfacefactory.h&gt;\n// The broker is a smart pointer (unique_ptr)\nauto server = BusInterfaceFactory::CreateBroker(\n    BrokerType::TcpServerType);\nserver-&gt;Name(\"TcpServer\"); // Name for internal use only\nserver-&gt;Address(\"127.0.0.1\");\nserver-&gt;Port(42612);\nserver-&gt;Start();    \n</code></pre>"},{"location":"message/bus_message/","title":"Bus Message","text":"<p>All message classes have a ToRaw() and a FromRaw() function that serialize and deserialize the message. The messages are pushed or popped from a message queue. The message queues are list of smart pointers. To create a message, use the following code.</p> <p><pre><code>#include &lt;bus/candataframe.h&gt;\n\nauto msg = std::make_shared&lt;CanDataFrame&gt;\n// Set the properties and message data (payload).\n\npublisher-&gt;Push(msg);\n</code></pre> Each CAN message, have a Time Stamp and a Bus Channel property. The Timestamp is always referencing nanoseconds since 1970-01-01 UTC (64-bit unsigned integer). The bus channel is 1\u2013255 and defines the source of the message.</p>"},{"location":"message/can_message/","title":"CAN Message","text":"<p>All message classes have a ToRaw() and a FromRaw() function that serialize and deserialize the message. The messages are pushed or popped from a message queue. The message queues are list of smart pointers.  To create a message, use the following code.</p> <p><pre><code>#include &lt;bus/candataframe.h&gt;\n\nauto msg = std::make_shared&lt;CanDataFrame&gt;\n// Set the properties and message data (payload).\n\npublisher-&gt;Push(msg);\n</code></pre> Each CAN message, have a Time Stamp and a Bus Channel property.  The Timestamp is always referencing nanoseconds since 1970-01-01 UTC (64-bit unsigned integer).  The bus channel is 1\u2013255 and defines the source of the message.</p> <p>Warning</p> <p>Each CAN message has a unique ID which in someway is a little bit unique. The CAN Message ID is the CAN ID with the 31:th bit indicating that the ID is extended. It is a common mistake to blend the CAN and Message ID within the code. </p>"},{"location":"message/can_message/#can-data-frame","title":"CAN Data Frame","text":"<p>The standard Data Frame message is the normal message on a functional CAN or CAN-FD bus. The CAN message can hold up to eight bytes while the CAN-FD message can hold up to 64 bytes of payload data.</p> CAN Data Frame Message Layout Byte (:Bits)DescriptionSize 0-17Message Header18 bytes 18-21Message ID (CAN Id + IDE)uint32_t 22DLCuint8_t 23Data Lengthuint8_t 24-27CRCuint32_t 28:0Direction (Rx=0, Tx=1)1-bit 28:1SRR1-bit 28:2EDL1-bit 28:3BRS1-bit 28:4ESI1-bit 28:5RTR1-bit 28:6R01-bit 28:7R11-bit 29:0Wake Up1-bit 29:1Single Wire1-bit 30-33Frame Duration (ns)/td&gt;uint32_t 34-xxData BytesData Length bytes"},{"location":"message/can_message/#message-id","title":"Message ID","text":"<p>The Message ID is a 32-bit value that includes an 11/27-bits CAN ID and  an Extended Address flag at the highest bit. The Extended flag defines if it is a 27-bits or an 11-bits address. Yes, this is confusing, but this is industry standard.</p>"},{"location":"message/can_message/#data-length-code-dlc","title":"Data Length Code (DLC)","text":"<p>The data length code (DLC) is somewhat an artifact.  The number of bytes and DLC are identical for CAN buses, but CAN-FD uses different code for more than 8-bytes payload bytes.</p> <p>Hint</p> <p>The class sets the DLC and Data Length properties automatically when the payload data is set.</p>"},{"location":"message/can_message/#checksum-crc","title":"Checksum (CRC)","text":"<p>The checksum is rarely used and is optional to use.</p>"},{"location":"message/can_message/#direction","title":"Direction","text":"<p>The Direction flag defines if the source (channel) was sending  this message or receiving it.  This is actually an enumerated value where 0 is Rx and 1 is Tx.</p>"},{"location":"message/can_message/#substitute-remote-request-srr","title":"Substitute Remote Request (SRR)","text":"<p>You need to ask a CAN expert about this flag.</p>"},{"location":"message/can_message/#extended-data-length-edl","title":"Extended Data Length (EDL)","text":"<p>The CAN-FD buses sets this flag to define that this is a CAN-FD frame.</p>"},{"location":"message/can_message/#bit-rate-switch-brs","title":"Bit Rate Switch (BRS)","text":"<p>Used by the CAN-FD bus.</p>"},{"location":"message/can_message/#error-state-indicator-esi","title":"Error State Indicator (ESI)","text":"<p>Used by the CAN-FD bus.</p>"},{"location":"message/can_message/#remote-frame-rtr","title":"Remote Frame (RTR)","text":"<p>Remote Frame flag defines that this is a remote frame. There is actually a special Remote Frame message defined.  Remote Frame doesn't include any payload data.</p>"},{"location":"message/can_message/#reserved-bit-0-and-1","title":"Reserved Bit 0 and 1","text":"<p>Undefined was these bits are used for.</p>"},{"location":"message/can_message/#wake-up","title":"Wake Up","text":"<p>Flag that indicates that this was a wake-up message.</p>"},{"location":"message/can_message/#single-wire-detected","title":"Single Wire Detected","text":"<p>Some hardware can detect if only one pin was used to detect the message.</p>"},{"location":"message/can_message/#frame-duration","title":"Frame Duration","text":"<p>Frame Duration of the message in nanoseconds. </p>"},{"location":"message/can_message/#can-remote-frame","title":"CAN Remote Frame","text":"<p>The Remote Frame is almost identical with the Data Frame but with the RTR flag set. There is no payload data sent with this message.</p>"},{"location":"message/can_message/#can-error-frame","title":"CAN Error Frame","text":"<p>The Error Frame is a normal Data Frame with error information.</p>"},{"location":"message/can_message/#can-overload-frame","title":"CAN Overload Frame","text":"<p>Seldom used message and is used mainly as an indication.</p>"},{"location":"message/control_message/","title":"Control Messages","text":"<p>The control messages are messages that are used internally to control driver interface.</p>"},{"location":"message/message_header/","title":"Message Header","text":"<p>All messages have the same 18-byte header.  The byte order is always little endian (Intel Byte Order). </p> Bus Message Header ByteDescriptionSize 0-1Type of Message (enumerate)uint16_t 2-3Version Numberuint16_t 4-7Length of the messageuint32_t 8-15Timestamp ns since 1970uint64_t 16-17Bus Channeluint16_t"},{"location":"message/message_header/#type-of-message","title":"Type of Message","text":"<p>Unique identifier of the message.  The message types are defined in the 'ibusmessage.h' header file.</p>"},{"location":"message/message_header/#version-number","title":"Version Number","text":"<p>Simple version number that is incremented each time the message layout is changed.</p>"},{"location":"message/message_header/#length-of-message","title":"Length of Message","text":"<p>The total length of the message includes this 18-byte header. A message must thus be larger or equal to 18 bytes.</p>"},{"location":"message/message_header/#timestamp","title":"Timestamp","text":"<p>The timestamp is always using the UTC time zone. The timestamp value is the number of nanoseconds since 1970-01-01 midnight.</p>"},{"location":"message/message_header/#bus-channel","title":"Bus Channel","text":"<p>This identifies the CAN device channel.  Note that many manufacture display the first channel (0) as 'Channel 1'.  The prefered way is to start the channel number at 1.</p>"}]}